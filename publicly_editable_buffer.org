google docs in emacs -*- mode: org -*-
#+STARTUP: showall

* Motivation

  Because google docs is cool, but emacs is better. Org mode is a great way to
  organize papers in production and whatnot, and emacs obviously offers
  keybindings that knock google docs out of the water. Each emacs user has their
  own functions and keybindings together, and this wouldn't get in the way of
  that at all. However, this could be really excellent for pair programming,
  especially if coupled with a chat interface. I don't think that's important to
  implement together, since many chat applications already exist, but it could
  be nice. This would be really cool to implement, since it might show that
  emacs's impossibly powerful-yet-friendly interface gives it an edge over
  these newfangled pretty text processors like atom or sublime.

* Required Pieces

  1. Method of grouping all users together in distributed fashion over network
  2. Method of having emacs collect and distribute changes to a file.
  3. Minor mode and command, maybe a separate window, to bring it all together

** User Grouping

   To take the obvious approach: make a single user initiate the buffer. Allow
   for file name changes, I suppose, through a special command. That single user
   creates some server which can mediate requests from other users. Approach
   this like google docs: make absolutely everything editable by absolutely
   everyone. It'll be fun.

   - User 0: begins server, which does I over port, O over other. edits buffer,
     maybe. file created on disk.
   - User 1: types command to join server (gets info to connect from user 1, who
     gets that info by typing some command).
   - User 1: edits buffer; changes immediately sent to user 0.
   - User 0: edits buffer; changes immediately sent to user 1.
   - User 2: joins server and sees file open, makes edits, changes sent to 0, 1.
   - User 3: joins server and sees file open, makes edits, changes sent to 0-2.
   - User 1: leaves, server no longer updates him, file saved to disk.
   - User 0: leaves, "server" abilities switch to either of users 2 or 3.

*** Server data contained:

    1. Current name of file, maintained across all participants
    2. Current list of all clients (including the client that began the
       session): this means connection info, basically.
    3. Logging of when changes occurred, I suppose.

** Changelogging and Distribution

   Want to implement all diffs in atomic sort of way; this can likely be
   accomplished by having a set time interval to poll for posts every few
   seconds, on both the client and server end.

   - Polling paradigm: each client saves all changes on their end every few
     seconds and uploads whatever info is required to identify the
     change. Server attempts to order these appropriately and atomically, and
     defaults to choosing [most/least] recent version if conflicts exist.
   - Push/pull paradigm: whenever change uploaded to server, server posts new
     version to all parties, which immediately update their local copies. When
     client makes change to local copy, emacs will save and update the server
     every few seconds. Lots of atomic operations.

   I would really like to make push/pull work cause I think it's cool, so away
   we go.

* Implementation

** User Grouping

   TODO: need method of starting new file or using existing file
   TODO: need method of merging two users' existing servers from two different
   sessions into one session, if they're working on the same file.

   User 0 starts server, which maintains:
   1. a queue of waiting changes, where "change" = user id, and intent to diff
   2. canon version of file
   3. list of clients and connection info
   User 0 also starts client, which maintains:
   1. "canon" file which is a mirror from the server.
   2. "tmp" file, produced after authenticating with server; contains diff of
      current buffer (fast-forwarded with server edits) with canon
      1. current version of file written to tmp, all diffs applied to both
         canon and tmp, then diff performed between tmp and canon
   3. server connection info

** Changelogging and Distribution

   If user sees changes in their buffer and a few seconds have passed since the
   initial change was made, they begin a post to the server. First, they pull
   changes again from the server.

   Further thoughts in distributed_control_solution.jpg

   Implementation of diffing algorithm in
   https://code.google.com/p/google-diff-match-patch/
